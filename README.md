# Рекурсивные алгоритмы. Комбинаторные алгоритмы. 
# Левченко Мария УИБО-09-24
# Вариант 18.
Реализуйте DFS для графа с выводом времени входа и выхода для каждой вершины. 	
## Описание работы алгоритма
#### 1. Инициализация структур данных
   
Алгоритм начинается с подготовки структур данных для отслеживания состояния обхода:

· Массив visited для отметки посещенных вершин

· Массивы time_in и time_out для записи временных меток

· Счетчик timer для генерации временных меток

#### 2. Рекурсивный процесс обхода
   
Для каждой обрабатываемой вершины выполняются следующие шаги:

Шаг 1: Вход в вершину

· Вершина помечается как посещенная: visited[v] = True

· Записывается время входа: time_in[v] = timer

· Счетчик времени увеличивается: timer += 1

Шаг 2: Обход смежных вершин

· Для каждого соседа текущей вершины проверяется условие: if not visited[neighbor]

· Если сосед не посещен, выполняется рекурсивный вызов: dfs_recursive(neighbor)

· Этот процесс продолжается до тех пор, пока не будут обработаны все достижимые вершины

Шаг 3: Выход из вершины

· После обработки всех соседей записывается время выхода: time_out[v] = timer

· Счетчик времени снова увеличивается: timer += 1

#### 3. Временные характеристики

· Время входа - момент начала обработки вершины

· Время выхода - момент завершения обработки всех потомков вершины

· Интервал [time_in, time_out] для родительской вершины полностью содержит интервалы всех ее потомков

#### 4. Завершение алгоритма
Алгоритм завершает работу, когда все вершины, достижимые из стартовой вершины, обработаны. Результатом работы являются заполненные массивы time_in и time_out, которые содержат полную временную структуру обхода графа.

## Временная сложность алгоритма
Временная сложность алгоритма DFS с временными метками составляет O(V + E), где V - количество вершин, а E - количество ребер в графе.

## Объяснение временной сложности
Такая сложность объясняется тем, что алгоритм посещает каждую вершину ровно один раз, что дает вклад O(V), и просматривает каждое ребро также ровно один раз, что добавляет O(E). Когда алгоритм начинает обход из стартовой вершины, он помечает ее как посещенную и записывает время входа, затем рекурсивно переходит ко всем ее непосещенным соседям. Ключевой момент заключается в том, что после установки флага visited[v] = True вершина больше никогда не обрабатывается повторно, что гарантирует линейное время выполнения. Обработка ребер происходит во время обхода соседей каждой вершины через цикл for neighbor in graph[v], где каждое ребро просматривается только один раз - при обработке исходящих связей из соответствующей вершины. Дополнительные операции, такие как запись времени входа time_in[v] = timer и времени выхода time_out[v] = timer, выполняются за константное время для каждой вершины и не влияют на асимптотическую сложность. Таким образом, общее время работы складывается из обработки всех вершин и всех ребер, что и дает итоговую сложность O(V + E). Эта сложность является оптимальной для полного обхода графа, поскольку любой алгоритм должен как минимум рассмотреть каждую вершину и каждое ребро хотя бы один раз.

## Ввод и вывод на разных языках
#### Python:
Ввод:

graph = [[1, 2], [3], [4], [], []]

start_vertex = 0

Вывод:

time_in = [0, 1, 5, 2, 6]

time_out = [9, 4, 8, 3, 7]

#### C++:
Ввод:

vector<vector<int>> graph = {{1, 2}, {3}, {4}, {}, {}}

int start_vertex = 0

Вывод:

time_in = [0, 1, 5, 2, 6]

time_out = [9, 4, 8, 3, 7]

#### Java:
Ввод:

List<List<Integer>> graph = Arrays.asList(

    Arrays.asList(1, 2),
    
    Arrays.asList(3),
    
    Arrays.asList(4),
    
    Arrays.asList(),
    
    Arrays.asList()
    
)

int startVertex = 0

Вывод:

result.timeIn = [0, 1, 5, 2, 6]

result.timeOut = [9, 4, 8, 3, 7]

